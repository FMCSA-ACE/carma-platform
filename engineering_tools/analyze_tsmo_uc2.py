#!/usr/bin/python3

#  Copyright (C) 2022 LEIDOS.
#
#  Licensed under the Apache License, Version 2.0 (the "License"); you may not
#  use this file except in compliance with the License. You may obtain a copy of
#  the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#  License for the specific language governing permissions and limitations under
#  the License.

from cProfile import label
from cmath import phase
import enum
from importlib.machinery import FileFinder
from inspect import TPFLAGS_IS_ABSTRACT
from operator import index, is_
from pprint import pprint
from random import random
import sys
import csv
from time import time, tzset
from unittest.mock import MagicProxy
from defer import return_value
import matplotlib.dates as mdates
from dateutil import parser
from tkinter.tix import LabelEntry
from turtle import color, left, width
from click import style
import matplotlib.pyplot as plt
import pytz
import scipy as sp
import rospy
import pandas as pd
import rosbag  # To import this, run the following command: "pip install --extra-index-url https://rospypi.github.io/simple/ rospy rosbag rospkg"
import datetime
import math
import numpy as np
import yaml
from rosbag.bag import Bag
import csv


TSC_phases_lookup = {
    0: "gray",
    1: "red",  # DARK
    2: "red",  # STOP_THEN_PROCEED
    3: "red",  # STOP_AND_REMAIN
    4: "gray",  # PRE_MOVEMENT
    5: "green",  # PERMISSIVE_MOVEMENT_ALLOWED
    6: "green",  # PROTECTED_MOVEMENT_ALLOWED
    7: "yellow",  # PERMISSIVE_CLEARANCE
    8: "yellow",  # PROTECTED_CLEARANCE
    9: "yellow",  # CAUTION_CONFLICTING_TRAFFIC
}


TSC_color2phases_lookup = {"red": [1, 2, 3], "green": [5, 6], "yellow": [7, 8, 9]}

Intersection_Bridge_Lanelet_Ids_list = [
    22161,
    21075,
    21487,
    20638,
    21197,
    20941,
    20821,
    21661,
    21905,
    22031,
    21311,
    21783,
]


class Vehicle_Guidance_Status_lookup(enum.Enum):
    SHUTDOWN = 0
    STARTUP = 1
    DRIVERS_READY = 2
    ACTIVE = 3
    ENGAGED = 4
    INACTIVE = 5
    ENTER_PARK = 6


class Route_Key_Name_lookup(enum.Enum):
    WEST_EAST_STRAIGHT = "west_east_straight"
    NORTH_EAST_STRAIGHT = "north_east_straight"


class Metric_Category_lookup(enum.Enum):
    UC2_M2_1 = "UC2-M2.1"
    UC2_M2_2 = "UC2-M2.2"
    UC2_M2_3 = "UC2-M2.3"
    UC2_M2_4 = "UC2-M2.4"
    UC2_M1_1 = "UC2-M1.1"


Route_Paths_lookup = {
    Route_Key_Name_lookup.WEST_EAST_STRAIGHT: [
        12459,
        1245999,
        1245998,
        21487,
        8226,
    ],
    Route_Key_Name_lookup.NORTH_EAST_STRAIGHT: [2748, 21311, 19249],
}


class metric_categories_profile:
    def __init__(self):
        self.metric_category_sum_dict = {}
        self.metric_category_list = []
        self.bag_count = 0

    def update_metric_category_list(self, metric_category_dict):
        self.metric_category_list.append(metric_category_dict)

    def update_mcp_sum_dict(self, category_name, run_result):
        """Update the metrics dictionary with metric names and its run result

        Args:
            category_name (string): Name of the metric category
            run_result (boolean): 1 or 0 to indicate whether the run result is successful or failed
        """
        if category_name in self.metric_category_sum_dict.keys():
            self.metric_category_sum_dict[category_name] = (
                self.metric_category_sum_dict[category_name] + run_result
            )
        else:
            self.metric_category_sum_dict[category_name] = run_result


class vehicle_profile_data:
    """
    Keep track of relevant vehicle metrics when the vehicle is engaged for plotting purposes. The vehicle profile metrics include:
    1) vehicle current speed over time (unit of second) during engaged
    2) vehicle current acceleration over time (unit of second) during engaged
    3) vehicle current downtrack over time (unit of second) during engaged
    4) vehicle received spat message every 1 second during engaged
    5) vehicle received map message every 1 second during engaged
    5) Bag name: The name of bag that is generated by the vehicle
    6) The route the vehicle traversed when engaged
    7) Vehicle engaged timestamp
    8) Vehicle disengaged timestamp
    9) Vehicle distance to the traffic signal location it faced over time (unit of second) when engaged
    10) vehicle current lanelet ID over time (unit of second) when engaged
    11) vehicle planner plugin names over timestamp when engaged
    12) Vehicle engaged status over timestamp
    """

    def __init__(self):
        self.cur_speeds_ts = {}
        self.cur_accels_ts = {}
        self.cur_downtracks_ts = {}
        self.speed_limits_ts = {}
        self.spat_phase_ts = {}
        self.spat_nums_ts = {}
        self.map_nums_ts = {}
        self.bag_name = ""
        self.route_name = ""
        self.vehicle_name = ""
        self.engage_start_ts = 0
        self.engage_end_ts = 0
        self.ds_tf_ts = {}
        self.cur_decels_ts = {}
        self.signal_group_id = 0
        self.intersection_id = 0
        self.lanelet_ids_ts = {}
        self.planner_plugin_names_ts = {}
        self.engage_status_ts = {}

    def update_cur_speeds_ts(self, cur_speed, timestamp):
        """Update the vehicle current latest speed given the timestamp

        Args:
            cur_speed (double): Vehicle current speed over time
            timestamp (_type_): unit of nanosecond
        """
        timestamp_s = math.floor(timestamp.to_sec())
        self.cur_speeds_ts[timestamp_s] = cur_speed

    def update_cur_accels_ts(self, cur_accel, timestamp):
        """Update the vehicle current average aceleration given the timestamp

        Args:
            cur_accel (double): Vehicle current acceleration over time
            timestamp (_type_): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        if timestamp_ts in self.cur_accels_ts.keys():
            self.cur_accels_ts[timestamp_ts] = (
                cur_accel + self.cur_accels_ts[timestamp_ts]
            ) / 2
        else:
            self.cur_accels_ts[timestamp_ts] = cur_accel

    def update_cur_decels_ts(self, cur_decel, timestamp):
        """Update the vehicle current average decelerations given the timestamp

        Args:
            cur_decel (double): Vehicle current decelerations over time
            timestamp (_type_): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        if timestamp_ts in self.cur_decels_ts.keys():
            self.cur_decels_ts[timestamp_ts] = (
                cur_decel + self.cur_decels_ts[timestamp_ts]
            ) / 2
        else:
            self.cur_decels_ts[timestamp_ts] = cur_decel

    def update_cur_downtracks_ts(self, cur_downtrack, timestamp):
        """Update the vehicle latest downtrack given the timestamp

        Args:
            cur_downtrack (double): Vehicle current distance to vehicle starting engagement location
            timestamp (timestamp): unit of nanosecond
        """
        timestamp_s = math.floor(timestamp.to_sec())
        self.cur_downtracks_ts[timestamp_s] = cur_downtrack

    def update_speed_limit_ts(self, speed_limit, timestamp):
        timestamp_s = math.floor(timestamp.to_sec())
        self.speed_limits_ts[timestamp_s] = speed_limit

    def update_spat_phase_ts(self, spat_phase, timestamp):
        """Update the spat phases dictionary given the timestamp

        Args:
            spat_phase (_type_): string of 'red','green' or 'yellow'
            timestamp (_type_): unit of nanosecond
        """
        timestamp_s = math.floor(timestamp.to_sec())
        self.spat_phase_ts[timestamp_s] = spat_phase

    def update_spat_nums_ts(self, spat_num, timestamp):
        """Update the number of spats given the timestamp

        Args:
            spat_num (_type_): integer 1
            timestamp (_type_): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        if timestamp_ts in self.spat_nums_ts.keys():
            self.spat_nums_ts[timestamp_ts] = spat_num + self.spat_nums_ts[timestamp_ts]
        else:
            self.spat_nums_ts[timestamp_ts] = spat_num

    def update_ds_tf_ts(self, distance2tf, timestamp):
        """Update the vehicle distance to traffic signal location it faced given the timestamp

        Args:
            distance2tf (double): _description_
            timestamp (timestamp): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        self.ds_tf_ts[timestamp_ts] = distance2tf

    def update_engage_status_ts(self, engage_status, timestamp):
        timestamp_ts = math.floor(timestamp.to_sec())
        self.engage_status_ts[timestamp_ts] = engage_status

    def update_map_num_ts(self, map_num, timestamp):
        timestamp_s = math.floor(timestamp.to_sec())
        """Update the number of maps given the timestamp.

        Args:
            map_num (_type_): integer between 1
            timestamp (_type_): unit of nanosecond
        """
        if timestamp_s in self.map_nums_ts.keys():
            self.spat_nums_ts[timestamp_s] = map_num + self.spat_nums_ts[timestamp_s]
        else:
            self.map_nums_ts[timestamp_s] = map_num

    def update_lanelet_ids_ts(self, lanelet_id, timestamp):
        """Update the vehicle current lanelet ID given the timestamp

        Args:
            lanelet_id (integer): Current lanelet ID
            timestamp (timestamp): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        self.lanelet_ids_ts[timestamp_ts] = lanelet_id

    def update_planner_plugin_names_ts(self, planner_plugin_name, timestamp):
        """Update the latest planner plugin name given the timestamp (unit of second)

        Args:
            planner_plugin_name (string): Name of the plugin that does the trajectory planning
            timestamp (timestamp): unit of nanosecond
        """
        timestamp_ts = math.floor(timestamp.to_sec())
        self.planner_plugin_names_ts[timestamp_ts] = planner_plugin_name

    def __profile__(self) -> str:
        """This function shows some profile information.

        Returns:
            str: summarized profile information.
        """
        cur_accel_info = ", ".join(
            [cur_accel_ts for cur_accel_ts in self.cur_accels_ts]
        )
        cur_speed_info = ", ".join(
            [cur_speed_ts for cur_speed_ts in self.cur_speeds_ts]
        )
        cur_track_info = ", ".join(
            [cur_downtrack_ts for cur_downtrack_ts in self.cur_downtracks_ts]
        )
        speed_limit_info = ", ".join(
            [speed_limit_ts for speed_limit_ts in self.speed_limits_ts]
        )
        spat_num_info = ", ".join([spat_tss for spat_tss in self.spat_ts])
        map_num_info = ", ".join([map_num_ts for map_num_ts in self.map_nums_ts])
        return f"{cur_accel_info} | {cur_speed_info} | {cur_track_info} | {speed_limit_info} | {spat_num_info} | {map_num_info}"

    def __prof_summary__(self) -> str:
        return f"Route name: {self.route_name}, vehicle from bag : {self.bag_name}, engaged start at timestamp {self.engage_start_ts}, engaged end at timestamp {self.engage_end_ts}"

    def __repr__(self) -> str:
        return f"{self.__profile__()}\n{self.__prof_summary__()}"

    def __str__(self) -> str:
        return self.__repr__()


###########################################################################################################
# TSMO UC2-M1.1 : Vehicles should receive SPaT messages from RSU
# once the vehicles enter the communication area until the vehicles depart the intersection box.
# Each vehicle processes this information and use it as inputs of the trajectory planning-related features
# (i.e., TS, the current CARMA Platform path following feature).
# The SPaT message information shall include timestamp, cycle length, phase sequence, phase durations,
#    current phase ID, and the remaining of the current phase durantion.
#
# Expected: True
###########################################################################################################


def get_metric_category_spats_result(vpd):
    """
    Args:
        vpd (vehicle_profile_data): vehicle profile data for each vehicle
    Required topics
    - SPaT Data : /message/incoming_spat cav_msgs/SPAT
    Other Required information
    - Movement Ids from the Spat that are needed for the vehicle and scenario being tested (may need to be a hard coded mapping)
    - Intersection Id for the spat. Since we have two intersections but only one is used in the test the id of interest should be hard coded into the analysis
    With the expected id we can verify that the required correct spat message is received.
    Approach:
    - Spat will provide the current light phase state by matching the movement id for the current scenario into the plan
    - Spat fields can be checked for availability to ensure the listed fields in the metric are available
    - Intersection id of the spat message can be checked to ensure it is the correct message being analyzed


    Returns:
        dictionary: key-value pair of category name and run test result of 0 (failed) or 1 (succeed)
    """
    is_succeed = 0  # 0 = failed; 1 = succeed
    is_vehicle_entered_intersection = False
    timestamp_at_intersection = 0
    for ts in vpd.lanelet_ids_ts.keys():
        if vpd.lanelet_ids_ts[ts] in Intersection_Bridge_Lanelet_Ids_list:
            # print("Found Bridge lanelet id = %s" % vpd.lanelet_ids_ts[ts])
            timestamp_at_intersection = ts
            is_vehicle_entered_intersection = True

    spat_timestamps = [key for key in vpd.spat_phase_ts.keys()]
    # print(spat_timestamps)
    if (
        len(spat_timestamps) > 0
        and is_vehicle_entered_intersection
        and spat_timestamps[0] <= timestamp_at_intersection
        and spat_timestamps[len(spat_timestamps) - 1] >= timestamp_at_intersection
    ):
        is_succeed = 1

    return is_succeed


###
# Mike suggested. MAP messages received and processed and they contain intersection ids matching the expected values
# This when combined with above metric confirms all required v2i information is available
# TODO implement if extra time
###

"""
Required topics
- Map Data : /message/incoming_map cav_msgs/Map
Other Required Data:
- Map messages have intersection Ids. Since we have two intersections but only one is used in the test the id of interest should be hard coded into the analysis
  With the expected id we can verify that the required map message is received. 
"""
###########################################################################################################
# TSMO UC2-M1.2 : The communication from infrastructure (RSU) to vehicle (OBU) should be within a certain frequency rates
#
# Expected: 10 Hz ± 1 Hz for SPaT, 1 Hz ± 0.5 Hz for MA
###########################################################################################################
def plot_spats_maps_frequency(plot_title, vehicles_plot_data_list, y_axis_max):
    subplot_nums = len(vehicles_plot_data_list)
    fig, ax = plt.subplots() if subplot_nums == 1 else plt.subplots(subplot_nums)
    print(
        "Detected %s numbers of vehicle(s)' profile data. Plotting >>  %s "
        % (subplot_nums, plot_title)
    )
    colors = ["blue", "orange", "purple", "cyan", "black", "brown", "gray"]
    fig.suptitle(plot_title, fontsize=14)
    i = 0
    styles = ["-", "-"]
    while i < subplot_nums:
        ax_local = ax if subplot_nums == 1 else ax[i]
        relative_spat_x_axis_idx = []
        key = "spat_idx"
        if key in vehicles_plot_data_list[i].keys():
            spat_idx = vehicles_plot_data_list[i]["spat_idx"]
            for idx in spat_idx:
                relative_spat_x_axis_idx.append(
                    idx.timestamp() - spat_idx[0].timestamp()
                )

            spat_df = pd.DataFrame(
                {
                    "Average SPAT Frequncy every 1s": vehicles_plot_data_list[i][
                        "spat_avg_frequency"
                    ]
                },
                index=relative_spat_x_axis_idx,
            )

            spat_df_sum_avg = pd.DataFrame(
                {
                    vehicles_plot_data_list[i]["v_name"]
                    + ": Average sum Frequncy SPAT": vehicles_plot_data_list[i][
                        "spat_sum_avg_frequency"
                    ]
                },
                index=relative_spat_x_axis_idx,
            )
            # Plot sum Avergage frequency
            spat_df_sum_avg.plot(ax=ax_local, style=styles[0], color=colors[0]) if len(
                relative_spat_x_axis_idx
            ) != 0 else ""
            # Sliding window frequency average
            ax_local.scatter(
                spat_df.index,
                spat_df.values,
                s=20,
                color=colors[2],
                marker="^",
                label=vehicles_plot_data_list[i]["v_name"]
                + ": Average SPAT Frequncy every 1s",
            ) if len(relative_spat_x_axis_idx) != 0 else ""

        relative_map_x_axis_idx = []
        key = "map_idx"
        if key in vehicles_plot_data_list[i].keys():
            map_idx = vehicles_plot_data_list[i]["map_idx"]
            for idx in map_idx:
                relative_map_x_axis_idx.append(idx.timestamp() - map_idx[0].timestamp())

            map_df = pd.DataFrame(
                {
                    "Average MAP Frequncy every 5s": vehicles_plot_data_list[i][
                        "map_avg_frequency"
                    ]
                },
                index=relative_map_x_axis_idx,
            )
            map_df_sum_avg = pd.DataFrame(
                {
                    vehicles_plot_data_list[i]["v_name"]
                    + ": Sum Average MAP Sum Frequncy": vehicles_plot_data_list[i][
                        "map_sum_avg_frequency"
                    ]
                },
                index=relative_map_x_axis_idx,
            )
            # Plot sum Avergage frequency
            map_df_sum_avg.plot(ax=ax_local, style=styles[1], color=colors[1]) if len(
                relative_map_x_axis_idx
            ) != 0 else ""
            # Sliding window frequency average
            ax_local.scatter(
                map_df.index,
                map_df.values,
                s=20,
                color=colors[3],
                marker="s",
                label=vehicles_plot_data_list[i]["v_name"]
                + ": Average MAP Frequncy every 5s",
            ) if len(relative_map_x_axis_idx) > 0 else ""
            ax_local.legend(loc="upper right")

        ax_local.set_ylabel(vehicles_plot_data_list[i]["y_label"])
        start_x, start_y = 0, 0
        ax_local.set_xlabel("Time (s)")
        stepsize_x, stepsize_y = 1, 1
        end_y = y_axis_max + stepsize_y
        ax_local.set_ylim(0, end_y)
        ax_local.set_yticks(np.arange(start_y, end_y, stepsize_y))
        end_x = (
            max(
                relative_map_x_axis_idx[len(relative_map_x_axis_idx) - 1]
                if len(relative_map_x_axis_idx) > 0
                else 0,
                relative_spat_x_axis_idx[len(relative_spat_x_axis_idx) - 1]
                if len(relative_spat_x_axis_idx) > 0
                else 0,
            )
            + stepsize_x
        )
        ax_local.set_xticks(np.arange(start_x, end_x, stepsize_x))
        i += 1


def show_spats_maps_frequency_profiles(vehicle_profiles_data):
    """
    Required topics
    - SPaT Data : /message/incoming_spat cav_msgs/SPAT
    - Map Data : /message/incoming_map cav_msgs/Map
    - Engagement status : /guidance/state cav_msgs/GuidanceState

    Approach:
    - After the first 3 Spat messages have been received consider communication stable enough for analysis (this may be before or after engagement)
    - Count the number of both spat and map starting from engagement to disengagement.
    Divide this number by the total time period of engagement to get total average frequency for each message
    - Additionally, create a 1s sliding window for spat and a 5s sliding window for map and verify that the average frequency within these windows never falls outside the specified ranges

    Plotting:
    - In addition to the pass/fail criterion plots should be generated of the frequency in the sliding windows at each timestep
    """
    vehicles_plot_data_list = []
    for vehicle_profile_data in vehicle_profiles_data:
        spat_nums_ts = [
            spat_num_ts for spat_num_ts in vehicle_profile_data.spat_nums_ts.keys()
        ]
        spat_nums_ts_list = []
        spat_sum_avg_frequency = []
        spat_nums_idx = []
        map_avg_freq = []
        map_sum_avg_frequency = []
        map_nums_idx = []

        if len(spat_nums_ts) != 0:
            date_time_1 = datetime.datetime.utcfromtimestamp(spat_nums_ts[0])
            date_time_5 = datetime.datetime.utcfromtimestamp(
                spat_nums_ts[len(spat_nums_ts) - 1]
            )
            spat_nums_idx = pd.date_range(date_time_1, date_time_5, freq="S")

            # Calculate average frequency for SPAT in every 1 second
            spat_nums_ts_list = [
                spat_num_ts
                for spat_num_ts in vehicle_profile_data.spat_nums_ts.values()
            ]
            # Calculate total average frequency for SPAT
            spat_sum_avg_frequency = [
                sum(spat_nums_ts_list)
                / (spat_nums_ts[len(spat_nums_ts) - 1] - spat_nums_ts[0])
            ]

        map_nums_ts = [
            map_num_ts for map_num_ts in vehicle_profile_data.map_nums_ts.keys()
        ]
        if len(map_nums_ts) != 0:
            date_time_1 = datetime.datetime.utcfromtimestamp(map_nums_ts[0])
            date_time_5 = datetime.datetime.utcfromtimestamp(
                map_nums_ts[len(map_nums_ts) - 1]
            )
            map_nums_idx = pd.date_range(date_time_1, date_time_5, freq="5S")
            map_nums_l = [
                map_num_ts for map_num_ts in vehicle_profile_data.map_nums_ts.values()
            ]
            # Calculate average frequency for MAP in every 5 second
            map_avg_freq = []
            i = 0
            count = 0
            map_nums_tmp = 0
            while count < len(map_nums_idx):
                if i + 4 < len(map_nums_l):
                    map_nums_tmp = (
                        map_nums_l[i]
                        + map_nums_l[i + 1]
                        + map_nums_l[i + 2]
                        + map_nums_l[i + 3]
                        + map_nums_l[i + 4]
                    )
                map_avg_freq.append(map_nums_tmp / 5)
                count += 1
                i += 5
            if len(map_avg_freq) == 0:
                print("ERROR: Map list size = 0")
                return
            if len(spat_nums_ts_list) == 0:
                print("ERROR: SPAT list size = 0")
                return

            # Calculate total average frequency for MAP
            map_sum_avg_frequency = [
                sum(map_nums_l) / (map_nums_ts[len(map_nums_ts) - 1] - map_nums_ts[0])
            ]

        v_name = vehicle_profile_data.vehicle_name
        vehicles_plot_data_dict = {
            "v_name": v_name,
            "spat_avg_frequency": spat_nums_ts_list,
            "spat_sum_avg_frequency": spat_sum_avg_frequency,
            "spat_idx": spat_nums_idx,
            "map_avg_frequency": map_avg_freq,
            "map_sum_avg_frequency": map_sum_avg_frequency,
            "map_idx": map_nums_idx,
            "y_label": "Frequency (HZ)",
        }
        vehicles_plot_data_list.append(vehicles_plot_data_dict)

    plot_title = "MAP and SPAT Frequency Profile"
    y_axis_max = (
        max(max(spat_nums_ts_list), max(map_avg_freq))
        if len(spat_nums_ts_list) > 0 and len(map_avg_freq)
        else 10
    )
    plot_spats_maps_frequency(plot_title, vehicles_plot_data_list, y_axis_max)


###########################################################################################################
# TSMO UC2-M2.1 : Each vehicle should travel sequentially through the lanelets defined in its path.
#
# Expected: True
# Note the expected set of lanelets changes based on the approach being used by the vehicle
###########################################################################################################
def get_metric_category_through_lanelets_result(vpd, vehicle_expected_paths):
    """
    Required topics
    - Current lanelet data : /guidance/route_state cav_msgs/RouteState
    - Engagement status : /guidance/state cav_msgs/GuidanceState

    Approach:
    - Hard code the expected lanelet ids for each approach in each test scenario
    - For a given run after the system is engaged, verify that the route_state reports the current lanelets in sequence following the same order as specified for the scenario and approach
    """
    is_succeed = 1
    vehicle_actual_lanelet_path = []
    is_entry_lanelet_expected = False
    for actual_lanelet_id in vpd.lanelet_ids_ts.values():
        if actual_lanelet_id in vehicle_expected_paths:
            is_entry_lanelet_expected = True
        if (
            actual_lanelet_id not in vehicle_actual_lanelet_path
            and is_entry_lanelet_expected
        ):
            vehicle_actual_lanelet_path.append(actual_lanelet_id)
    i = 0
    for actual_lanelet_id in vehicle_actual_lanelet_path:
        if actual_lanelet_id != vehicle_expected_paths[i]:
            is_succeed = 0
        i += 1
    return is_succeed


###########################################################################################################
#
# NOTE: This metric may get tweaked. Suggest tackling last

# TSMO UC2-M2.2 : Each vehicle shall process the SPaT message
# and adjust its speed such that it can enter the intersection box at a green phase with minimum or no stopping
# Specifically the vehicle should on average stop for less time then would be required by the baseline case of EET (Earliest entry time)
#
# Expected: Vehicle's actual stopping time is less then predicted from EET
#
# TODO implement
###########################################################################################################

"""
Required topics
- Not a topic, but will need knowledge of current test case being evaluated to determine expected behavior.
- Current lanelet and downtrack: /guidance/route_state cav_msgs/RouteState
- Engagement status : /guidance/state cav_msgs/GuidanceState
- Current_speed : /hardware_interface/vehicle/twist geometry_msgs/TwistStamped (http://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/TwistStamped.html)
- SPaT Data : /message/incoming_spat cav_msgs/SPAT

Other Required Data:
- Log file from lci_strategic_plugin with DEBUG logs enabled. This is needed to get the EET value
- Intersection and movement ids for identifying correct spat

Approach: 
- At the start of vehicle engagement look in the lci_strategic_plugin log file for the first occurrence of "earliest_entry_time" This will be the EET value. (from ROS_DEBUG_STREAM("earliest_entry_time: " << std::to_string(earliest_entry_time.toSec()) << ", with : " << earliest_entry_time - current_state.stamp  << " left at: " << std::to_string(current_state.stamp.toSec()));)
- Using the EET value determine if the light was red, yellow, or green from SPAT
- If the light was red at EET then find the next time when the light turns green
-- Save the delta between next green start and EET (will refer to as BaseCaseStopTime)
-- Based on the data determine how much time the vehicle was at a stop at the stop bar while engaged (will refer to as VehicleStopTime)
-- If VehicleStopTime < BaseCaseStopTime 
---- Record a Successes (algorithm performs better than base case)
- If the light was green at EET 
-- If the vehicle stops in this case,
---- Record failure
-- else 
---- Record success
- If the light was yellow at EET
-- If the vehicle stops 
---- Record success
-- If the vehicle does not stop
---- Record failure


"""

###########################################################################################################
# TSMO UC2-M2.3 : Vehicles shall not enter the intersection box at yellow or red phases.
#
# Expected: True
###########################################################################################################


def get_metric_category_enter_intersection2TSC_result(vpd):
    """
    Required topics
    - Current lanelet data : /guidance/route_state cav_msgs/RouteState
    - Engagement status : /guidance/state cav_msgs/GuidanceState
    - SPaT Data : /message/incoming_spat cav_msgs/SPAT
    Other Required Data:
    - The intersection and movement ids expected for the vehicle and scenario being tested

    Approach:
    - Use the intersection id and movement id to identify the current phase of the light which is required
    - Use the route_state to determine the current lanelet of the vehicle
    - While the vehicle is engaged, its reported lanelet should never be one inside the intersection while the phase state is not green
    """
    is_succeed = 0
    timestamp_at_intersection = 0
    for ts in vpd.lanelet_ids_ts.keys():
        if vpd.lanelet_ids_ts[ts] in Intersection_Bridge_Lanelet_Ids_list:
            timestamp_at_intersection = ts
    is_succeed = (
        1
        if vpd.spat_phase_ts[timestamp_at_intersection]
        in TSC_color2phases_lookup["green"]
        else 0
    )
    return is_succeed


###########################################################################################################
# TSMO UC2-M2.4 : Each vehicle should switch away from the TS mode after entering the intersection box
# Note that the intersection box is the box per the HD map, which may not be exactly as physically seen on the road.
# Expected: True
###########################################################################################################
def get_metric_category_enter_intersection2TSMode_result(vpd):
    """
    Required topics
    - Current lanelet data : /guidance/route_state cav_msgs/RouteState
    - Engagement status : /guidance/state cav_msgs/GuidanceState
    - Determine lci plugin is used in planning : /guidance/plan_trajectory cav_msgs/TrajectoryPlan

    Approach:
    - When the vehicle is engaged, gets its current lanelet from the route state
    - Verify that when the lanelet is one inside the intersection the current planning trajectory is not coming from the lci tactical plugin
    - To check the controlling tactical plugin look at the planner_plugin field of the first point on the current plan_trajectory
    """
    is_succeed = 0
    timestamp_at_intersection = 0
    for ts in vpd.lanelet_ids_ts.keys():
        if vpd.lanelet_ids_ts[ts] in Intersection_Bridge_Lanelet_Ids_list:
            timestamp_at_intersection = ts
    # print(vpd.planner_plugin_names_ts.values())
    # print(vpd.planner_plugin_names_ts[timestamp_at_intersection].lower())
    is_succeed = (
        1
        if vpd.planner_plugin_names_ts[timestamp_at_intersection].lower()
        not in [
            "lci_strategic_plugin",
            "lightcontrolledintersectiontacticalplugin",
        ]
        else 0
    )
    return is_succeed


###
# Mike suggested. Vehicle does not violate speed limit my more than 1 mph
# Good to confirm as this showed up as an issue multiple times during integration testing
# TODO implement if extra time
###
"""
Required topics
- Engagement status : /guidance/state cav_msgs/GuidanceState
- Current_speed : /hardware_interface/vehicle/twist geometry_msgs/TwistStamped
Other Required Data:
- Speed limit extracted from map

Approach:
- In TSMO UC2 all the speed limits will be the same so a simple conditional while the vehicle is engaged on twist.linear.x will suffice to check if the limit is exceeded
"""


def load_rosbags_to_vehicles_profile(bag_vehicle_names):
    """Read the bags given the bags paths. Populate the vehicle profile data python object, and add the object to a list of vehicle profiles.

    Returns:
        _type_: list of vehicle_profile_data
    """
    vehicles_profiles = []
    # loop bags to get relevant vehicles information and update the vehicles profile list
    for bag_name in bag_vehicle_names.keys():
        print("Loading bag (name = %s) ..." % bag_name)
        vpd = vehicle_profile_data()
        is_engaged = False
        engage_start_ts = 0
        engage_end_ts = 0
        try:
            bag = Bag(bag_name, "r")
        except:
            print("Bad bag file name or path for %s. Skipped it!!!" % bag_name)
            continue

        # Vehicle engage timestamp
        for topic, msg, t in bag.read_messages(topics=["/guidance/state"]):
            # print(msg.state)
            vpd.update_engage_status_ts(msg.state, t)
            if (
                (not is_engaged)
                and msg.state == Vehicle_Guidance_Status_lookup.ENGAGED.value
                and engage_start_ts == 0
            ):
                print("Vehicle is engaged at timestamp = ", t)
                engage_start_ts = t
                is_engaged = True
            elif (
                is_engaged and msg.state != Vehicle_Guidance_Status_lookup.ENGAGED.value
            ):
                print("Vehicle is disengaged at timestamp = ", t)
                engage_end_ts = t
                is_engaged = False
                break

        if (
            engage_start_ts == 0
            or engage_end_ts == 0
            or engage_start_ts > engage_end_ts
        ):
            print("Bad Bag file. Vehicle has never engaged.")
            return

        # Only interested in data when vehicle is engaged
        if (
            engage_start_ts != 0
            and engage_end_ts != 0
            and engage_start_ts <= engage_end_ts
        ):
            vpd.engage_start_ts = engage_start_ts
            vpd.engage_end_ts = engage_end_ts
            vpd.bag_name = bag_name
            vpd.vehicle_name = bag_vehicle_names[bag_name]

            # Traffic Signal Group and intersection ids
            for topic, msg, t in bag.read_messages(
                topics=["/environment/intersection_signal_group_ids"]
            ):
                vpd.signal_group_id = msg.data[1]
                vpd.intersection_id = msg.data[0]

            topics = [
                "/hardware_interface/vehicle/twist",
                "/message/incoming_spat",
                "/message/incoming_map",
                "/hardware_interface/velocity_accel_cov",
                "/guidance/route_state",
                "/guidance/lci_strategic_plugin/distance_remaining_to_tf",
                "/guidance/plan_trajectory",
            ]

            # topics_tmp = bag.get_type_and_topic_info()[1].keys()
            # for topic in topics_tmp:
            #     pprint(topic)
            for topic, msg, t in bag.read_messages(topics=topics):
                if t >= engage_start_ts and t <= engage_end_ts:
                    if topic == "/hardware_interface/vehicle/twist":
                        vehicle_cur_speed = msg.twist.linear.x
                        timestamp = t
                        vpd.update_cur_speeds_ts(vehicle_cur_speed, timestamp)
                        # print(msg)
                    elif topic == "/message/incoming_spat":
                        """The SPaT message information shall include timestamp, cycle length, phase sequence, phase durations,
                        current phase ID, and the remaining of the current phase durantion."""
                        spat_phase = 0
                        for intersection_state in msg.intersection_state_list:
                            if intersection_state.id.id == vpd.intersection_id:
                                for movement_list in intersection_state.movement_list:
                                    if (
                                        movement_list.signal_group
                                        == vpd.signal_group_id
                                    ):
                                        spat_phase = movement_list.movement_event_list[
                                            0
                                        ].event_state.movement_phase_state
                        vpd.update_spat_nums_ts(1, t)
                        vpd.update_spat_phase_ts(spat_phase, t)
                        # print(msg)
                    elif topic == "/message/incoming_map":
                        # print(msg)
                        vpd.update_map_num_ts(1, t)
                    elif topic == "/hardware_interface/velocity_accel_cov":
                        # print(msg)
                        vehicle_cur_accel = msg.accleration
                        timestamp = t
                        vpd.update_cur_accels_ts(vehicle_cur_accel, timestamp)
                    elif (
                        topic
                        == "/guidance/lci_strategic_plugin/distance_remaining_to_tf"
                    ):
                        # print(msg)
                        vpd.update_ds_tf_ts(msg.data, t)
                    elif topic == "/guidance/route_state":
                        # print(msg.down_track)
                        # print(msg)
                        vehicle_cur_downtrack = msg.down_track
                        vehicle_cur_speed_limit = msg.speed_limit
                        lanelet_id = msg.lanelet_id
                        # print(lanelet_id)
                        timestamp = t
                        vpd.update_cur_downtracks_ts(vehicle_cur_downtrack, timestamp)
                        vpd.update_speed_limit_ts(vehicle_cur_speed_limit, timestamp)
                        vpd.update_lanelet_ids_ts(lanelet_id, timestamp)
                        vpd.route_name = msg.routeID
                    elif topic == "/guidance/plan_trajectory":
                        # print(msg)
                        if len(msg.trajectory_points) > 0:
                            ppn = msg.trajectory_points[0].planner_plugin_name
                            timestamp = t
                            vpd.update_planner_plugin_names_ts(ppn, timestamp)
        # Finished loading bag data into the vehicle profile object. Add the vehicle profile into the list
        # print(vpd.spat_nums_ts)
        # print(vpd.spat_phase_ts)
        # print(vpd.map_nums_ts)
        # print(vpd.ds_tf_ts)
        # print(vpd.engage_status_ts)
        # print(vpd.cur_downtracks_ts)
        vehicles_profiles.append(vpd)

    return vehicles_profiles


def plot_vehicle_speed_accel_downtrack_with_tsc(
    vehicles_plot_data,
    tsc_bar_height,
    max_y_axis,
    y_axis_stepsize,
    plot_title,
):
    subplot_nums = len(vehicles_plot_data)
    print(
        "Detected %s numbers of vehicle(s)' profile data. Plot vehicle(s)' profile(s) with TSC. Plotting >>  %s "
        % (subplot_nums, plot_title)
    )
    fig, ax = plt.subplots() if subplot_nums == 1 else plt.subplots(subplot_nums)
    colors = ["blue", "black", "purple", "cyan", "orange", "brown"]
    fig.suptitle(plot_title, fontsize=14)
    i = 0
    relative_x_axis_max = 0
    tmp = []
    for vpd in vehicles_plot_data:
        ts_tmp = vpd[vpd["profile_name"] + "_idx"]
        tmp.append(ts_tmp[len(ts_tmp) - 1].timestamp() - ts_tmp[0].timestamp())
    relative_x_axis_max = max(tmp)

    for vpd in vehicles_plot_data:
        # Vehicle info lines
        ts_idx = vpd[vpd["profile_name"] + "_idx"]
        # print(vpd)
        df = pd.DataFrame(vpd, index=ts_idx)
        relative_x_axis_idx = []
        for idx in ts_idx:
            relative_x_axis_idx.append(idx.timestamp() - ts_idx[0].timestamp())
        ax_local = ax if subplot_nums == 1 else ax[i]
        ax_local.plot(
            relative_x_axis_idx,
            df[vpd["profile_name"]],
            color=colors[i],
            label=vpd["v_name"],
        )
        ax_local.legend(loc="upper right")
        tsc_start_y = vpd["tsc_start_y"]

        # # Traffic signal with horizontal bars
        period_count_start = relative_x_axis_idx[0]
        period_count_start_end = relative_x_axis_idx[len(relative_x_axis_idx) - 1]
        start_phase_pos = 0
        is_green_label_displayed = False
        is_red_label_displayed = False
        is_yellow_label_displayed = False
        for phase in vpd["tsc_phases"]:
            if TSC_phases_lookup[phase] in "yellow" and not is_yellow_label_displayed:
                is_yellow_label_displayed = True
                tsc_label = "Yellow Phase = " + str(phase)
            elif TSC_phases_lookup[phase] in "red" and not is_red_label_displayed:
                is_red_label_displayed = True
                tsc_label = "Red Phase = " + str(phase)
            elif TSC_phases_lookup[phase] in "green" and not is_green_label_displayed:
                is_green_label_displayed = True
                tsc_label = "Green Phase = " + str(phase)
            else:
                tsc_label = ""
            ax_local.broken_barh(
                [(start_phase_pos, 1)],
                (tsc_start_y, tsc_bar_height),
                facecolors=TSC_phases_lookup[phase],
                label=tsc_label if len(tsc_label) != 0 else "",
                alpha=vpd["tsc_alpha"],
            )
            start_phase_pos += 1
        ax_local.legend(loc="upper right")

        # x-axis and y-axis
        ax_local.grid(True)
        ax_local.set_xlabel("Time (s)")
        ax_local.set_ylabel(vpd["y_label"])
        start_x, start_y = 0, 0
        stepsize_x = 1  # unit of second
        end_x, end_y = (
            # max(period_count_start, period_count_start_end) + stepsize_x,
            relative_x_axis_max + stepsize_x,
            max_y_axis + y_axis_stepsize,
        )
        ax_local.set_xticks(np.arange(start_x, end_x, stepsize_x))
        ax_local.xaxis.set_tick_params(width == 2)
        ax_local.set_yticks(np.arange(start_y, end_y, y_axis_stepsize))
        ax_local.set_xlim(0, end_x)
        i += 1


###########################################################################################################
# Additional Requested Plots: Speed over time with matching signal state shown
###########################################################################################################
def show_vehicles_speed_profiles(vehicle_profiles_data):
    """
    Required topics
    - Engagement status : /guidance/state
    - Current_speed : /hardware_interface/vehicle/twist
    - SPaT Data : /message/incoming_spat

    Other Required Data:
    - Intersection id and movement id for the spat message

    Approach:
    - While the vehicle is engaged plot the current speed twist.linear.x
    - Also plot the signal phase as red, green, yellow bars on the same graph

    NOTE: This plot should be generated in two forms 1 time for the individual vehicles and once as a single plot combing the data from two vehicles
    """
    vehicles_plot_data_list = []
    for vehicle_profile_data in vehicle_profiles_data:
        cur_speed_idx = [
            cur_speed_idx for cur_speed_idx in vehicle_profile_data.cur_speeds_ts.keys()
        ]
        date_time_1 = datetime.datetime.utcfromtimestamp(cur_speed_idx[0])
        date_time_5 = datetime.datetime.utcfromtimestamp(
            cur_speed_idx[len(cur_speed_idx) - 1]
        )
        cur_speed_ts_idx = pd.date_range(date_time_1, date_time_5, freq="S")
        cur_speed_list = [
            cur_speed for cur_speed in vehicle_profile_data.cur_speeds_ts.values()
        ]
        phase_list = [
            cur_phase for cur_phase in vehicle_profile_data.spat_phase_ts.values()
        ]

        ds_tf_ts = [value for value in vehicle_profile_data.ds_tf_ts.values()]

        v_name = vehicle_profile_data.vehicle_name

        tsc_start_y = 0
        tsc_bar_height = 15
        tsc_alpha = 0.5  # opacity of bars
        vehicles_plot_data_dict = {
            "v_name": v_name,
            "profile_name": "speed",
            "speed": cur_speed_list,
            "speed_idx": cur_speed_ts_idx,
            "y_label": "Speed (m/s)",
            "tsc_phases": phase_list if len(phase_list) != 0 else "",
            "tsc_start_y": tsc_start_y,
            "tsc_alpha": tsc_alpha,
        }
        vehicles_plot_data_list.append(vehicles_plot_data_dict)

    max_y_axis = max(
        max(vehicles_plot_data_list[0]["speed"]), tsc_bar_height + tsc_start_y
    )
    y_axis_stepsize = 1
    plot_title = "Vehicle Speed Profile"
    plot_vehicle_speed_accel_downtrack_with_tsc(
        vehicles_plot_data_list,
        tsc_bar_height,
        max_y_axis,
        y_axis_stepsize,
        plot_title,
    )


###########################################################################################################
# TSMO UC2-M2.3_1 : The average deceleration\acceleration over any 1-second portion of the test time horizon
# shall be no greater than 3.0 m/s^2.
#
# Expected: acceleration <= 3.0 m/s^2 deceleration >= -3.0 m/s^2
###########################################################################################################

"""
Required topics
- Engagement status : /guidance/state cav_msgs/GuidanceState
- Current_speed : /hardware_interface/vehicle/twist (use to compute accel) geometry_msgs/TwistStamped
- Vehicle accel : /hardware_interface/velocity_accel_cov (use as alternative source of accel) automotive_platform_msgs/VelocityAccelCov (https://github.com/astuff/automotive_autonomy_msgs/blob/master/automotive_platform_msgs/msg/VelocityAccelCov.msg)

Approach:
- While the vehicle is engaged, create a 1s sliding window and take the start and end speed for each timestep of the window and compute the average acceleration
- Additionally, verify that the abs(/hardware_interface/velocity_accel_cov reported value) never exceeds 3.0 for more than 1 timestep at any point during engagement
"""

###########################################################################################################
# Additional Requested Plots: Acceleration over time with matching signal state shown
###########################################################################################################
def show_vehicles_accel_profiles(vehicle_profiles_data):
    """
    Required topics
    - Engagement status : /guidance/state
    - Current_speed : /hardware_interface/vehicle/twist (use to compute accel)
    - Vehicle accel : /hardware_interface/velocity_accel_cov (use as alternative source of accel)
    - SPaT Data : /message/incoming_spat
    Other Required Data:
    - Intersection id and movement id for the spat message

    Approach:
    - While the vehicle is engaged plot the current acceleration
    - Also plot the signal phase as red, green, yellow bars on the same graph

    NOTE: This plot should be generated in two forms 1 time for the individual vehicles and once as a single plot combing the data from two vehicles
    """
    vehicles_plot_data_list = []
    for vehicle_profile_data in vehicle_profiles_data:
        cur_accels_ts = [
            cur_accels_ts for cur_accels_ts in vehicle_profile_data.cur_speeds_ts.keys()
        ]
        date_time_1 = datetime.datetime.utcfromtimestamp(cur_accels_ts[0])
        date_time_5 = datetime.datetime.utcfromtimestamp(
            cur_accels_ts[len(cur_accels_ts) - 1]
        )
        cur_accel_ts_idx = pd.date_range(date_time_1, date_time_5, freq="S")
        cur_accel_list = [
            cur_accel for cur_accel in vehicle_profile_data.cur_accels_ts.values()
        ]

        phase_list = [
            cur_phase for cur_phase in vehicle_profile_data.spat_phase_ts.values()
        ]

        ds_tf_ts = [value for value in vehicle_profile_data.ds_tf_ts.values()]

        v_name = vehicle_profile_data.vehicle_name

        tsc_start_y = 0
        tsc_bar_height = 3
        tsc_alpha = 0.3  # opacity of bars
        vehicles_plot_data_dict = {
            "v_name": v_name,
            "profile_name": "accel",
            "accel": cur_accel_list,
            "accel_idx": cur_accel_ts_idx,
            "y_label": "Accel (m/s^2)",
            "tsc_phases": phase_list if len(phase_list) != 0 else "",
            "tsc_start_y": tsc_start_y,
            "tsc_alpha": tsc_alpha,
        }
        vehicles_plot_data_list.append(vehicles_plot_data_dict)
    max_y_axis = max(
        max(vehicles_plot_data_list[0]["accel"]), tsc_bar_height + tsc_start_y
    )
    y_axis_stepsize = 1
    plot_title = "Vehicle Acceleration Profile"
    plot_vehicle_speed_accel_downtrack_with_tsc(
        vehicles_plot_data_list,
        tsc_bar_height,
        max_y_axis,
        y_axis_stepsize,
        plot_title,
    )


###########################################################################################################
# Additional Requested Plots: Downtrack position over time with matching signal state shown
###########################################################################################################
def show_vehicles_downtrack_profiles(vehicle_profiles_data):
    """
    Required topics
    - Engagement status : /guidance/state
    - Current downtrack data : /guidance/route_state
    - SPaT Data : /message/incoming_spat
    Other Required Data:
    - Intersection id and movement id for the spat message

    Approach:
    - While the vehicle is engaged plot the current downtrack distance reported by route_state
    - Identify where the stop bar is in terms of downtrack distance (this might change per run)
    - At the position where the stop bar is (y-axis) draw a set of red/green/yellow rectangles showing the current signal phase

    NOTE: This plot should be generated in two forms 1 time for the individual vehicles and once as a single plot combing the data from two vehicles
    """
    vehicles_plot_data_list = []
    # BP = False
    for vehicle_profile_data in vehicle_profiles_data:
        cur_downtrack_ts = [
            cur_downtrack_ts
            for cur_downtrack_ts in vehicle_profile_data.cur_downtracks_ts.keys()
        ]
        date_time_1 = datetime.datetime.utcfromtimestamp(cur_downtrack_ts[0])
        date_time_5 = datetime.datetime.utcfromtimestamp(
            cur_downtrack_ts[len(cur_downtrack_ts) - 1]
        )
        cur_downtrack_ts_idx = pd.date_range(date_time_1, date_time_5, freq="S")
        cur_downtrack_list = [
            cur_downtrack
            for cur_downtrack in vehicle_profile_data.cur_downtracks_ts.values()
        ]
        # if BP:
        #     cur_downtrack_list = [
        #         cur_downtrack - 290 for cur_downtrack in cur_downtrack_list
        #     ]
        # BP = True
        phase_list = [
            cur_phase for cur_phase in vehicle_profile_data.spat_phase_ts.values()
        ]

        ds_tf_ts = [value for value in vehicle_profile_data.ds_tf_ts.values()]
        # print(ds_tf_ts)
        # print(cur_downtrack_list)

        v_name = vehicle_profile_data.vehicle_name

        # Traffic Signal bars config
        tsc_start_y = max(ds_tf_ts)
        tsc_bar_height = round(max(cur_downtrack_list) / 10)
        tsc_alpha = 1  # opacity of bars
        vehicles_plot_data_dict = {
            "v_name": v_name,
            "profile_name": "downtrack",
            "downtrack": cur_downtrack_list,
            "downtrack_idx": cur_downtrack_ts_idx,
            "y_label": "Downtrack (m)",
            "tsc_phases": phase_list if len(phase_list) != 0 else "",
            "tsc_start_y": tsc_start_y,
            "tsc_alpha": tsc_alpha,
        }
        vehicles_plot_data_list.append(vehicles_plot_data_dict)

    max_downtrack = 0
    for item in vehicles_plot_data_list:
        if max_downtrack < max(item["downtrack"]):
            max_downtrack = max(item["downtrack"])
    max_y_axis = max(max_downtrack, tsc_bar_height + tsc_start_y)
    y_axis_stepsize = round(max_y_axis / 10)
    plot_title = "Vehicle Downtrack Profile"
    plot_vehicle_speed_accel_downtrack_with_tsc(
        vehicles_plot_data_list,
        tsc_bar_height,
        max_y_axis,
        y_axis_stepsize,
        plot_title,
    )


def show_vehicles_distance2tf_profiles(vehicle_profiles_data):
    """
    Required topics
    - Engagement status : /guidance/state
    - Current downtrack data : /guidance/route_state
    - SPaT Data : /message/incoming_spat
    Other Required Data:
    - Intersection id and movement id for the spat message

    Approach:
    - While the vehicle is engaged plot the current downtrack distance reported by route_state
    - Identify where the stop bar is in terms of downtrack distance (this might change per run)
    - At the position where the stop bar is (y-axis) draw a set of red/green/yellow rectangles showing the current signal phase

    NOTE: This plot should be generated in two forms 1 time for the individual vehicles and once as a single plot combing the data from two vehicles
    """
    vehicles_plot_data_list = []
    for vehicle_profile_data in vehicle_profiles_data:
        ds_tf_timestamp = [key for key in vehicle_profile_data.ds_tf_ts.keys()]
        date_time_1 = datetime.datetime.utcfromtimestamp(ds_tf_timestamp[0])
        date_time_5 = datetime.datetime.utcfromtimestamp(
            ds_tf_timestamp[len(ds_tf_timestamp) - 1]
        )
        ds_tf_ts_idx = pd.date_range(date_time_1, date_time_5, freq="S")
        ds_tf_ts = [value for value in vehicle_profile_data.ds_tf_ts.values()]
        ds_tf_ts_reverse = [
            max(ds_tf_ts) - value for value in vehicle_profile_data.ds_tf_ts.values()
        ]

        phase_list = [
            cur_phase for cur_phase in vehicle_profile_data.spat_phase_ts.values()
        ]

        v_name = vehicle_profile_data.vehicle_name

        # Traffic Signal bars config
        tsc_start_y = max(ds_tf_ts)
        tsc_bar_height = round(max(ds_tf_ts) / 10)
        tsc_alpha = 1  # opacity of bars
        vehicles_plot_data_dict = {
            "v_name": v_name,
            "profile_name": "distance2tf",
            "distance2tf": ds_tf_ts_reverse,
            "distance2tf_idx": ds_tf_ts_idx,
            "y_label": "Distance (m)",
            "tsc_phases": phase_list if len(phase_list) != 0 else "",
            "tsc_start_y": tsc_start_y,
            "tsc_alpha": tsc_alpha,
        }
        vehicles_plot_data_list.append(vehicles_plot_data_dict)

    max_y_axis = max(
        max(vehicles_plot_data_list[0]["distance2tf"]), tsc_bar_height + tsc_start_y
    )
    y_axis_stepsize = round(max_y_axis / 10)
    plot_title = "Vehicle Distance"
    plot_vehicle_speed_accel_downtrack_with_tsc(
        vehicles_plot_data_list,
        tsc_bar_height,
        max_y_axis,
        y_axis_stepsize,
        plot_title,
    )


def show_vehicles_profiles(vehicle_profiles_data):
    show_vehicles_speed_profiles(vehicle_profiles_data)
    # show_vehicles_accel_profiles(vehicle_profiles_data)
    show_vehicles_downtrack_profiles(vehicle_profiles_data)
    show_vehicles_distance2tf_profiles(vehicle_profiles_data)
    show_spats_maps_frequency_profiles(vehicle_profiles_data)


def load_rosbags_result_to_metric_categories_profile(
    vehicle_profiles_data, vehicle_expected_paths_names, vehicle_alias_names
):
    """
    Plot the vehicle information from the ROS bags generated by vehicles
    """
    if type(vehicle_profiles_data).__name__ == "NoneType":
        print("Cannot load bags")
        return

    mcp = metric_categories_profile()
    for vpd in vehicle_profiles_data:
        mcp.bag_count += 1
        mpc_through_lanelets = get_metric_category_through_lanelets_result(
            vpd,
            vehicle_expected_paths_names[vpd.vehicle_name],
        )

        mcp.update_mcp_sum_dict(
            Metric_Category_lookup.UC2_M2_1.name,
            mpc_through_lanelets,
        )

        # metric_category_stoptime2EET_result= get_metric_category_stoptime2EET_result( vpd
        # )
        # mcp.update_mcp_sum_dict(
        #     Metric_Category_lookup.UC2_M2_2.name, metric_category_stoptime2EET_result
        # )

        mpc_enter_intersection2tsc_result = (
            get_metric_category_enter_intersection2TSC_result(vpd)
        )

        mcp.update_mcp_sum_dict(
            Metric_Category_lookup.UC2_M2_3.name,
            mpc_enter_intersection2tsc_result,
        )

        mpc_enter_intersection2TSMode_result = (
            get_metric_category_enter_intersection2TSMode_result(vpd)
        )

        mcp.update_mcp_sum_dict(
            Metric_Category_lookup.UC2_M2_4.name,
            mpc_enter_intersection2TSMode_result,
        )

        mpc_spats = get_metric_category_spats_result(vpd)

        mcp.update_mcp_sum_dict(
            Metric_Category_lookup.UC2_M1_1.name,
            mpc_spats,
        )

        mcp_dict = {
            "bag_name": vpd.bag_name,
            "vehicle_name": vpd.vehicle_name,
            "vehicle_alias": vehicle_alias_names[vpd.vehicle_name],
            Metric_Category_lookup.UC2_M2_1.name: mpc_through_lanelets,
            # Metric_Category_lookup.UC2_M2_2.name: metric_category_stoptime2EET_result,
            Metric_Category_lookup.UC2_M2_3.name: mpc_enter_intersection2tsc_result,
            Metric_Category_lookup.UC2_M2_4.name: mpc_enter_intersection2TSMode_result,
            Metric_Category_lookup.UC2_M1_1.name: mpc_spats,
        }
        mcp.update_metric_category_list(mcp_dict)

    # print(mcp.metric_category_list)
    # print(mcp.metric_category_sum_dict)
    return mcp


def load_mcp_runs_to_excel(mcp, mc_keys):
    mpc_rl = mcp.metric_category_list
    if len(mpc_rl) > 0:
        fieldnames = [
            "Vehicle Name",
            "Metrics Category",
            "Bag Name",
            "Run Result (1-success: 0-failure)",
        ]
        row = 0
        row_list = []
        row_list.append(fieldnames)
        for mpc_row in mpc_rl:
            for mc_key in mc_keys:
                row_item = [
                    mpc_row["vehicle_alias"],
                    mc_key,
                    mpc_row["bag_name"],
                    mpc_row[mc_key],
                ]
                row_list.append(row_item)

        with open("mcp_RUNS_results.csv", mode="w") as mcp_run_results:
            writer = csv.writer(mcp_run_results)
            writer.writerows(row_list)
    else:
        print("EMPTY MPC List")


def load_mcp_sum_to_excel(mcp, mc_description, bag_vehicle_names):
    mpc_sum_dict = mcp.metric_category_sum_dict
    total_bags_nums = len(bag_vehicle_names)
    if len(mpc_sum_dict.keys()) > 0:
        fieldnames = [
            "Metrics Category",
            "Metrics Description",
            "Expected Result",
            "Test Result (Success Rate %)",
            "Bag Names",
        ]
        row_list = []
        row_list.append(fieldnames)
        for mc_key in mc_description.keys():
            row_item = [
                mc_key,
                mc_description[mc_key],
                "True",
                mpc_sum_dict[mc_key] / total_bags_nums * 100,
                ",".join(bag_vehicle_names.keys()),
            ]
            row_list.append(row_item)

        with open("mcp_SUM_results.csv", mode="w") as mcp_sum_results:
            writer = csv.writer(mcp_sum_results)
            writer.writerows(row_list)
    else:
        print("EMPTY MPC Dict")


def plot_mcp_runs(mcp, metric_categories, vehicles_alias):
    fig, ax = (
        plt.subplots(len(vehicles_alias)) if len(vehicles_alias) > 1 else plt.subplot()
    )
    mc_idx = ["Failed", "Succeed"]
    i = 0
    for vehicle_name in vehicles_alias:
        mc_ls = plot_mcp_runs_by_vehicle(mcp, metric_categories, vehicle_name)
        # print("Vehicle Name vehicle_name >>> %s" %vehicle_name)
        print(mc_ls)
        df = pd.DataFrame(
            {
                "UC2_M1.1_" + str(vehicle_name): mc_ls["UC2_M1_1"],
                "UC2_M2.1_" + str(vehicle_name): mc_ls["UC2_M2_1"],
                "UC2_M2.3_" + str(vehicle_name): mc_ls["UC2_M2_3"],
                "UC2_M2.4_" + str(vehicle_name): mc_ls["UC2_M2_4"],
            },
            index=mc_idx,
        )
        local_ax = ax[i] if len(vehicles_alias) > 1 else ax
        df.plot.bar(rot=0, ax=local_ax)
        local_ax.set_ylabel("Number of runs")
        local_ax.set_title("Vehicles Metrics")
        local_ax.legend(loc="upper right")
        i += 1
    fig.tight_layout()
    plt.show()


def plot_mcp_runs_by_vehicle(mcp, metric_categories, vehicle_name):
    mpc_rl = mcp.metric_category_list
    is_success = 1
    is_failed = 0
    mc_ls = {}
    for mc_name in metric_categories:
        mc_ls[mc_name] = [0, 0]
        for mpc_r in mpc_rl:
            if mpc_r["vehicle_alias"] == vehicle_name:
                if (mpc_r[mc_name]) == is_success:
                    mc_ls[mc_name][is_success] += 1
                else:
                    mc_ls[mc_name][is_failed] += 1
    return mc_ls


def plot_bags():
    """
    Plot the vehicle information from the ROS bags generated by vehicles
    """
    # Vehicle and bag names should be unique
    bag_vehicle_names = {
        "data/CC-RG_BL_E1_R20_2022-04-01-20-17-25.bag": "BL_E1_R20",  # Blue Lexus:   RUN 1
        # "data/CC-RG_BL_E1_R30_2022-04-01-20-27-36.bag": "BL-E1_R30",  # Blue Lexus: RUN 2
        # "data/CC-RG_BL_E2_G22_2022-04-01-20-44-10_badbag.bag": "BL_E2_G22",  # Blue Lexus:  RUN 3
        # "data/CC-RG_BL_E2_R05_2022-04-01-20-59-30.bag": "BL_E2_R05",  # Blue Lexus:
        # "data/CC-RG_BP_E1_G2_2022-04-01-21-08-24.bag": "BP_E1_G2",  # Black Pacifica:
        "data/CC-RG_BP_E2_G17_2022-04-01-20-14-27.bag": "BP_E2_G17",  # Black Pacifica: RUN 1
        # "data/CC-RG_BP_E1_R25_2022-04-01-20-42-45.bag": "BP_E1_R25",  # # Black Pacifica: RUN 3
    }

    print(
        "PLOT BAG DATA: Found %d number(s) of engaged vehicle(s) profiles in the bags in TSMO uc2 use case."
        % len(bag_vehicle_names)
    )
    vehicle_profiles_data_v2v_pair = load_rosbags_to_vehicles_profile(bag_vehicle_names)
    show_vehicles_profiles(vehicle_profiles_data_v2v_pair)

    plt.legend(loc="upper right")
    plt.show()


def load_bags2excel2mcp_plot():
    """
    Summarize and save the vehicle analyze result based on information from the ROS bags generated by vehicles
    """
    bag_vehicle_names = {
        "data/CC-RG_BL_E1_R20_2022-04-01-20-17-25.bag": "BL_E1_R20",  # Blue Lexus:   RUN 1
        # "data/CC-RG_BL_E1_R30_2022-04-01-20-27-36.bag": "BL-E1_R30",  # Blue Lexus: RUN 2
        # "data/CC-RG_BL_E2_G22_2022-04-01-20-44-10_badbag.bag": "BL_E2_G22",  # Blue Lexus:  RUN 3
        # "data/CC-RG_BL_E2_R05_2022-04-01-20-59-30.bag": "BL_E2_R05",  # Blue Lexus:
        # "data/CC-RG_BP_E1_G2_2022-04-01-21-08-24.bag": "BP_E1_G2",  # Black Pacifica:
        "data/CC-RG_BP_E2_G17_2022-04-01-20-14-27.bag": "BP_E2_G17",  # Black Pacifica: RUN 1
        # "data/CC-RG_BP_E1_R25_2022-04-01-20-42-45.bag": "BP_E1_R25",  # # Black Pacifica: RUN 3
    }
    vehicle_alias_names = {
        "BL_E2_R05": "Blue_Lexus",  # Blue Lexus:
        "BL_E1_R30": "Blue_Lexus",  # Blue Lexus:
        "BL_E1_R20": "Blue_Lexus",  # Blue Lexus:
        "BP_E2_G17": "Black_Pacifica",  # Black Pacifica:
        "BP_E1_G2": "Black_Pacifica",  # Black Pacifica:
    }
    vehicle_expected_paths_names = {
        "BL_E1_R30": Route_Paths_lookup[Route_Key_Name_lookup.WEST_EAST_STRAIGHT],
        "BL_E1_R20": Route_Paths_lookup[Route_Key_Name_lookup.WEST_EAST_STRAIGHT],
        "BP_E1_G2": Route_Paths_lookup[Route_Key_Name_lookup.NORTH_EAST_STRAIGHT],
        "BP_E2_G17": Route_Paths_lookup[Route_Key_Name_lookup.NORTH_EAST_STRAIGHT],
        "BL_E2_R05": Route_Paths_lookup[Route_Key_Name_lookup.NORTH_EAST_STRAIGHT],
    }

    print(
        "EXCEL/SUM BAG DATA: Found %d number(s) of engaged vehicle(s) profiles in the bags in TSMO uc2 use case."
        % len(bag_vehicle_names)
    )
    vehicle_profiles_data2mcp = load_rosbags_to_vehicles_profile(bag_vehicle_names)
    mcp = load_rosbags_result_to_metric_categories_profile(
        vehicle_profiles_data2mcp,
        vehicle_expected_paths_names,
        vehicle_alias_names,
    )
    mc_description = {
        Metric_Category_lookup.UC2_M1_1.name: "Each vehicle should travel sequentially through the lanelets defined in its path.",
        Metric_Category_lookup.UC2_M2_1.name: "vehicle's actual stopping time is less then predicted from EET",
        Metric_Category_lookup.UC2_M2_3.name: "Vehicles shall not enter the intersection box at yellow or red phases.",
        Metric_Category_lookup.UC2_M2_4.name: "Each vehicle should switch away from the TS mode after entering the intersection box",
    }
    load_mcp_runs_to_excel(mcp, mc_description.keys())
    load_mcp_sum_to_excel(mcp, mc_description, bag_vehicle_names)
    plot_mcp_runs(
        mcp, mc_description.keys(), set(v for v in vehicle_alias_names.values())
    )


# Main Function; run all tests from here
# TODO: The contents of this main function provide some basic structure for loading data, but need not be followed if not applicable
def main():
    if len(sys.argv) < 2:
        print(
            "Need 1 arguments: process_bag.py <path to source folder with .bag files> "
        )
        exit()

    source_folder = sys.argv[1]

    # Re-direct the output of print() to a specified .txt file:
    orig_stdout = sys.stdout
    current_time = datetime.datetime.now()
    text_log_filename = "Results_" + str(current_time) + ".txt"
    text_log_file_writer = open(text_log_filename, "w")
    sys.stdout = text_log_file_writer

    # Create .csv file to make it easier to view overview of results (the .txt log file is still used for more in-depth information):
    csv_results_filename = "Results_" + str(current_time) + ".csv"
    csv_results_writer = csv.writer(open(csv_results_filename, "w"))

    # TODO update this list
    csv_results_writer.writerow(
        [
            "Bag Name",
            "Vehicle Name",
            "Test Type",
            "WZ-1 Result",
            "WZ-2 Result",
            "WZ-3 Result",
            "WZ-4 Result",
            "WZ-5 Result",
            "WZ-6 Result",
            "WZ-7 Result",
            "WZ-8 Result",
            "WZ-9 Result",
            "WZ-10 Result",
            "WZ-11 Result",
            "WZ-12 Result",
            "WZ-13 Result",
            "WZ-14 Result",
            "WZ-15 Result",
            "WZ-16 Result",
            "WZ-17 Result",
            "WZ-18 Result",
            "WZ-19 Result",
            "WZ-20 Result",
            "WZ-21 Result",
            "WZ-22 Result",
            "WZ-23 Result",
            "WZ-24 Result",
            "WZ-25 Result",
        ]
    )

    # TODO identify cases and assign bags to each case
    # Create list of Red Light Workzone Black Pacifica bag files to be processed
    black_pacifica_red_bag_files = []

    # Create list of Red Light Workzone Ford Fusion bag files to be processed
    ford_fusion_red_bag_files = [
        "_2021-09-22-16-00-28-red.bag",
        "_2021-09-22-19-03-26-red.bag",
    ]

    # Create list of Red Light Workzone Blue Lexus bag files to be processed
    blue_lexus_red_bag_files = []

    # Create list of Green Light Workzone Black Pacifica bag files to be processed
    black_pacifica_green_bag_files = []

    # Create list of Green Light Workzone Ford Fusion bag files to be processed
    ford_fusion_green_bag_files = []

    # Create list of Green Light Workzone Blue Lexus bag files to be processed
    blue_lexus_green_bag_files = []

    # Concatenate all Basic Travel bag files into one list
    red_light_bag_files = (
        black_pacifica_red_bag_files
        + ford_fusion_red_bag_files
        + blue_lexus_red_bag_files
    )
    green_light_bag_files = (
        black_pacifica_green_bag_files
        + ford_fusion_green_bag_files
        + blue_lexus_green_bag_files
    )
    WZ_bag_files = red_light_bag_files + green_light_bag_files

    # Loop to conduct data anlaysis on each bag file:
    for bag_file in WZ_bag_files:
        print("*****************************************************************")
        print("Processing new bag: " + str(bag_file))
        # TODO update bags groups
        if bag_file in black_pacifica_red_bag_files:
            print(
                "Black Pacifica Red Light Workzone Test Case"
            )  # TODO update conditionals here
        elif bag_file in ford_fusion_red_bag_files:
            print("Ford Fusion Red Light Workzone Test Case")
        elif bag_file in blue_lexus_red_bag_files:
            print("Blue Lexus Red Light Workzone Test Case")
        if bag_file in black_pacifica_green_bag_files:
            print("Black Pacifica Green Light Workzone Test Case")
        elif bag_file in ford_fusion_green_bag_files:
            print("Ford Fusion Green Light Workzone Test Case")
        elif bag_file in blue_lexus_green_bag_files:
            print("Blue Lexus Green Light Workzone Test Case")

        # Print processing progress to terminal (all other print statements are re-directed to outputted .txt file):
        sys.stdout = orig_stdout
        print(
            "Processing bag file "
            + str(bag_file)
            + " ("
            + str(WZ_bag_files.index(bag_file) + 1)
            + " of "
            + str(len(WZ_bag_files))
            + ")"
        )
        sys.stdout = text_log_file_writer

        # Process bag file if it exists and can be processed, otherwise skip and proceed to next bag file
        try:
            print("Starting To Process Bag at " + str(datetime.datetime.now()))
            bag_file_path = str(source_folder) + "/" + bag_file
            bag = rosbag.Bag(bag_file_path)
            print("Finished Processing Bag at " + str(datetime.datetime.now()))
        except:
            print("Skipping " + str(bag_file) + ", unable to open or process bag file.")
            continue

        # Get the rosbag times associated with the starting engagement and ending engagement for the Basic Travel use case test
        # TODO update to remove geofence information
        print("Getting engagement times at " + str(datetime.datetime.now()))
        # TODO get engagement times
        # time_test_start_engagement, time_test_end_engagement, found_test_times = get_test_case_engagement_times(bag)
        print("Got engagement times at " + str(datetime.datetime.now()))
        found_test_times = True  # TODO remove these placeholder values
        time_test_start_engagement = 0.0
        time_test_end_engagement = 1.0
        if not found_test_times:
            print(
                "Could not find test case engagement start and end times in bag file."
            )
            continue

        # Debug Statements
        print("Engagement starts at " + str(time_test_start_engagement.to_sec()))
        print("Engagement ends at " + str(time_test_end_engagement.to_sec()))
        print(
            "Time spent engaged: "
            + str((time_test_end_engagement - time_test_start_engagement).to_sec())
            + " seconds"
        )

        # TODO implement
        original_speed_limit = 1.0  # TODO remove placeholder
        # original_speed_limit = get_route_original_speed_limit(bag, time_test_start_engagement) # Units: m/s
        print("Original Speed Limit is " + str(original_speed_limit) + " m/s")

        # Initialize results
        # TODO updates results
        wz_1_result = None
        wz_2_result = None
        wz_3_result = None
        wz_4_result = None
        wz_5_result = None
        wz_6_result = None
        wz_7_result = None
        wz_8_result = None
        wz_9_result = None
        wz_10_result = None
        wz_11_result = None
        wz_12_result = None
        wz_13_result = None
        wz_14_result = None
        wz_15_result = None
        wz_16_result = None
        wz_17_result = None
        wz_18_result = None
        wz_19_result = None
        wz_20_result = None
        wz_21_result = None
        wz_22_result = None
        wz_23_result = None
        wz_24_result = None
        wz_25_result = None
        wz_26_result = None
        wz_27_result = None

        # TODO call metric functions

        # Write simple pass/fail results to .csv file for appropriate row:
        csv_results_writer.writerow(
            [
                bag_file,
                vehicle_name,
                vehicle_role,
                wz_1_result,
                wz_2_result,
                wz_3_result,
                wz_4_result,
                wz_5_result,
                wz_6_result,
                wz_7_result,
                wz_8_result,
                wz_9_result,
                wz_10_result,
                wz_11_result,
                wz_12_result,
                wz_13_result,
                wz_14_result,
                wz_15_result,
                wz_16_result,
                wz_17_result,
                wz_18_result,
                wz_19_result,
                wz_20_result,
                wz_21_result,
                wz_22_result,
                wz_23_result,
                wz_24_result,
                wz_25_result,
            ]
        )

    sys.stdout = orig_stdout
    text_log_file_writer.close()
    return


if __name__ == "__main__":
    # main()
    plot_bags()
    # load_bags2excel2mcp_plot()
